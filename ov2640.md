
# ov2640 摄像头模块

关键在于学习如何操作寄存器
k210的dvp datasheet:

> 3.9 数字视频接口(DVP)
> DVP 是摄像头接口模块，特性如下：
> * 支持DVP接口的摄像头
> * 支持SCCB协议配置摄像头寄存器
> * 最大支持640X480 及以下分辨率，每帧大小可配置
> * 支持YUV422 和RGB565 格式的图像输入
> * 支持图像同时输出到KPU和显示屏:
>   * 输出到KPU 的格式可选RGB888，或YUV422输入时的Y分量
>   * 输出到显示屏的格式为RGB565
> * 检测到一帧开始或一帧图像传输完成时可向CPU发送中断


# 接口
PCLK,即像素时钟,一个PCLK时钟,输出一个(或半个)像素。

VSYNC,即帧同步信号。

HREF/ HSYNC,即行同步信号。

## 颜色格式 RGB, YUV, YCbCr


## sccb

SCCB 特性都与 I2C 无区别, 可以直接用I2C控制器去通信

## dvp
各种大大小小的时钟, 最终形成了同步的信号. 一个帧同步信号的有效时间内有很多个行同步信号, 每个行同步信号的有效时间内有很多像素时钟.

## 输出格式
SVGA: 800 x 600
摄像头也可以配置缩放. 没写怎么配置的缩放的.


## 图形翻转
0xFF=1的时候, 04寄存器最高两位分别是水平镜像和垂直翻转. 
widora的ov2640例程中, 注释了airv r3 back的地方是 d8 也就是这两位都有.

## 代码对比阅读
linux的ov2640代码可能是发源地, 也是最完善的吧. 接着是openmv的代码, 比maixpy的整齐很多, 不乱. 接着就是kendryte的代码, 也许是参照openmv的,对比一下widora的例程. 最后是maixpy的代码.

## widora对比kentryte

代码的对比最好先format后diff. 这样即使widora他们声明数组是好几个一行, 也能迅速展平方便对比

经过对比发现, 除了多设置了一个翻转bit之外, 只有这两个不同.
官方是
```
    {0x5a, 0xc8},
    {0x5b, 0x96},
```
widora是
```
    {0x5a, 0x50},
    {0x5b, 0x3C},
```
搜索ov2640和zmow, 找到了Android的相关驱动代码!!! Android它们相关驱动可能比linux还完善.

#define ZMOW        0x5A /* Zoom: Out Width  OUTW[7:0] (real/4) */
#define   ZMOW_OUTW_SET(x)      VAL_SET(x, 0xFF, 2, 0)
#define ZMOH        0x5B /* Zoom: Out Height OUTH[7:0] (real/4) */

这样看的话, widora是: 320\*240分辨率. 官方是800\*600, 修改这里确实说得过去, 不过也不注释一下...

没想到这样的例程都用到了ai加速器?
```c
    // 设置允许导流到AI模型
    dvp_set_output_enable(0, 1);    //enable to ai
    // DVP不直接导流到LCD
    dvp_set_output_enable(1, 1);    //disable to lcd
```
dvp_set_ai_addr设置AI 存放图像的地址，供AI 模块进行算法处理。
void dvp_set_ai_addr(uint32_tr_addr, uint32_tg_addr, uint32_tb_addr)设置采集图像在内存中的存放地址，可以用来显示。
dvp_clear_interrupt(DVP_STS_FRAME_START | DVP_STS_FRAME_FINISH); 一般表示当前的这种中断处理完了, 可以来新的中断了. 算是是中断的pending位?.
dvp_config_interrupt(DVP_CFG_START_INT_ENABLE | DVP_CFG_FINISH_INT_ENABLE, 1); 打开中断开关
dvp_start_convert() 在开始采集图像的时候调用 表示开始采集图像
dvp_disable_auto() 禁用自动接收图像模式。

总结起来, 就是开启dvp中断. k210的dvp会提供开始采集和停止采集的两种中断. 开始采集的时候, 在中断处理中调用start_convert. 结束采集的时候, 设置标志位. 当中断退出的时候, 忙等的处理器就会注意到标志位, 清零并设置切换buffer的标志, 向屏幕发送数据. 另外就是中断处理的时候根据buffer标志设置buffer.
根据需要切换buffer是在结束采集的时候?? 不应该啊, 切换buffer不是为了让采集和输出不在同一个buffer吗.

根据LCD的需求来切换dvp数据放到哪个缓存，目的是保证把图像传给LCD的时候, dvp不是正好输出到这个buf。

buf大小上, ai为什么要给三个RGB的buf? 我修改了zoom出来的大小是否相关的buf大小也需要变化?
查看发现widora和官方的main函数一直, buf大小相同.
RGB565是2字节一个像素. 这里是320\*240\*2 = 38400个uint32 (widora的dvp buffer大小.)
而AI的buffer大小是3\*12c00 = 38400 这是怎么回事? RGB怎么可能均分呢? 这可是RGB565.

set_framesize在设置QVGA的时候不仅设置了dvp_set_image_size, 也设置了摄像头那边的zoom寄存器.


## ov2640 帧率
分析software application notes的帧率设置案例.
下面的寄存器都在0xff=1的情况下
首先是0x11寄存器, 最低4位为clock dividor. 寄存器的值高帧率的时候为0, 低的时候为1, 可能divide了就帧率减半吗?
0x12寄存器的(低到高)第三位, zoom mode. svga的时候设为1, uxga的时候为0
0x2a寄存器, 大家都设置为0 line interval adjust value的高四位, Hsync start/end point adjustment MSB. 0x2b也为0, line interval adjust value的低8位. 帧率会被这个12bit的值微调. 
0x46为低位, 0x47为高位, 组成了frame length adjustment. 这个值每多1, 就在帧中增加了1个水平线的时间. 0x47大家也都设置为0. 这个值是调整帧率的关键.
0x3d寄存器很神秘, 在手册的保留寄存器的范围内. svga设置为了0x38, uxga设置成了0x34

SVGA 800×600来看的话, 高度是600. frame length adjustment为0时的刷新率是30fps. 而增加了clock dividor, 帧率减半得到15fps. 如果只frame length adjustment设置为了0x87=135, 那么帧率就乘上了缩放倍数(600/600+135), 得到25fps.

|type|clock dividor| frame length adjustment|
|-|-|-|
|widora/kendryte|0|0x22|
|maixpy|0|0x22|

## ov2460 颜色
0xff=
CTRL0 = 0xC2寄存器 最低四位由低到高依次为RAW_EN, RGB_EN, YUV_EN, YUV422. 默认和maixpy的配置都是0x0C=1100
0xDA寄存器的名字是IMAGE_MODE, bit0 byte swap for DVP(low/high byte first), bit\[3:2\] 00->yuv422, 01->raw10, 10-> RGB565, 11->Reserved
kendryte是0x08, 也就是RGB565, maixpy是0x01, 也就是YUV422+byte swap

这边寄存器的设置要和那边dvp的接收设置匹配起来. 而调用picformat只是设置dvp的接收的格式. 


## maixpy和openmv的代码解析

openmv的代码更大型一些, 功能更多. 对摄像头相关的寄存器使用得更灵活. 前面的配置一般还是svga, 但是最后zoom出来分辨率不会那么大.

```
import sensor    
import lcd

lcd.init()

sensor.reset()
sensor.set_pixformat(sensor.RGB565)
sensor.set_framesize(sensor.QVGA)
sensor.run(1)

while True:
    img = sensor.snapshot()
    lcd.display(img)
```
先在这个典型的例程里, 依次分析一下各个函数.
代码结构依次是py_sensor.c -> sensor.c -> ov2460.c
首先是探测过程, 读取厂家和型号id. ov2460_init函数会填写sensor结构体, 暴露出内部函数.
设置frame_size的时候, 也会设置摄像头的zoom相关寄存器.
set_pixformat似乎没有用了, 而且似乎是yuv. 设置成其他的格式会花屏. 也许是方便直接输入模型吧.
set_framerate也无法设置, ov2460.c中直接返回-1了.

sensor和lcd没有直接的关联或者相互调用, snapshot函数则是传过去的关键.
snapshot函数甚至还对buf做了什么jpeg压缩处理, 考虑了连接ide的情况.

超时不一定是摄像头配置问题. 也可能是中断处理问题. 试了下去掉双buf选项编译还是不行

```
    #ifdef CONFIG_BOARD_AIRVR3
	{0x5a, 0x50},
	{0x5b, 0x3c},
    #else
	{0x5a, 0xc8},
	{0x5b, 0x96},
    #endif
	{0x5c, 0x00},
	{0xc3, 0xed},
	{0x7f, 0x00},
	{0xe5, 0x1f},
	{0xdd, 0x7f},
	{0x05, 0x00},
#if 1	//color bar
	{0xff, 0x01},
	{0x12, 0x02},
#endif
```


## 其他尝试
reduced the clock to 11MHz, 似乎能提高帧率

图像格式的问题, 搞清楚是怎么设置的. 八成不是中断的问题...
把RGB关掉试试, 用YUV也是好的

测试情况:
使用airv配置 不注释svga, 有时花屏有时正常显示, 图像也上下左右反了
使用maixpy配置有时无法显示, 有时正常

不会显示异常的关键是选对dvp的颜色格式和摄像头配置的颜色格式

maixpy的摄像头相关还是不太行, 可能有bug. 这里如果不设置framesize就直接snapshot, 会报错Not init.
之后居然就崩了...

这就是软件工程的困境吗?

等一波新版本发布, github watch了

不会是供电问题吧... 只有程序小的时候才能正常显示


