---
title: 数据结构复习笔记
date: 2019/6/25 20:46:25
categories:
- 大学
tags:
- 数据结构
- 算法
---


# 数据结构复习笔记
1. 数据结构的基本概念
数据结构是一门讨论“描述现实世界实体的数学模型（非数值计算）及其上的操作在计算机中如何表示和实现”的学科。
<!-- more -->
## 广义表?

## 线性表
1. 特点
在非空的线性表，有且仅有一个开始结点a1，它没有直接前趋，而仅有一个直接后继a2；
有且仅有一个终端结点an，它没有直接后继，而仅有一个直接前趋an-1；
其余的内部结点ai (2≦i≦n-1) 都有且仅有一个直接前趋 ai-1和一个直接后继 ai+1。
2. 例题
顺序存储 链式存储


3. 顺序表
顺序表的成员
 1 存储元素的一维数组空间
 2 顺序表中已有的元素个数
 3 存放的数据元素个数的最大值
进行一次插入操作时需要移动的元素个数的平均值：n/2
进行一次删除操作时需要移动的元素个数的平均值为：(n-1)/2
顺序存储表示仅适用于不常进行插入和删除操作、表中元素相对稳定的线性表。
相关操作:
 &emsp;无序线性表的合并O(ListLength(L\*A)\*ListLength(LB))
 &emsp;有序线性表的合并O(ListLength(LA)＋ListLength(LB))
从 B 中挑选出所有“彼此相异”的元素(有序)
 &emsp;判别两个集合是否相等。
 &emsp;2-4 比较大小操作O (Min(A.length, B.length))
 &emsp;2-5 用尽可能少的辅助空间将顺序表中前 m 个元素和后 n 个元素进行互换(依次插入法，逆置法)

4. 单链表
优势:
能有效利用存储空间；
用“指针”指示数据元素之间的后继关系，便于进行“插入”、“删除”等操作；
劣势则是不能随机存取数据元素
静态链表:用数组描述的链表
循环链表:判别链表中最后一个结点的条件不再是"后继是否为空"，而是"后继是否为头结点"。
相关操作:
&emsp;销毁结构操作O (Listlength(L))
&emsp;存取元素操作O (ListLength(L))
&emsp;插入/删除元素操作(要找到对应节点)O (ListLength(L))
&emsp;2-7 逆序创建链表O (ListLength(L))
&emsp;删除单链表中"多余"的数据元素O (ListLength2(L))
&emsp;有序表去重为O (ListLength(L))
&emsp;有序表归并
&emsp;
&emsp;

## 栈
1. 原表达式转换成后缀式
如果是数字直接递过去
栈底放#
遇到运算符就看前一个运算符的优先级,如果前一个运算符优先级高,就可以把前一个算出来
2. 判断合法的栈混洗的序列
出栈序列中的每个数后面的比它小的数，是按递减排列的。

## 队列
队列的修改是依先进先出的原则进行的。
1. 链队列
队列的链式存储结构简称为链队列, 增加一个尾指针, 便于在表尾做插入操作.
2. 循环队列
循环队列（队列的顺序表示和实现）
在非空队列中，头指针始终指向队头元素，而尾指针指向队尾元素的“下一个”位置。
只凭Q.front==Q.rear无法判断队列是“空”或“满”, 可以另设标志位以区别队列是“空”或“满”；或者少用一个元素空间，以“队列头指针在队列尾指针的下一位置上”作为队列“满”；
队尾指针的“数值”有可能比队头指针的数值小，因此为避免在求队列长度两者相减时出现负值的情况，在作取模运算之前先加上一个最大容量的值。
## 串
对串而言，是以串的整体作为操作对象, 串类型不能和线性表类型混为一谈。
1. 串的定长顺序存储表示
直接使用定长的字符数组来定义，数组的上界预先给出
2. 串的堆分配存储表示
也称为动态存储分配的顺序表
插入操作的基本思想是构造一个新的串。因此首先要为被插入串S重新分配存储空间
3. 串的块链存储表示
串的操作都是从前往后进行的，因此串的链表通常不设双链
通常是在一个结点中存放多个字符
以块链作存储结构时实现串的操作很不方便
4. 串匹配
4.1 暴力匹配
时间复杂度为O(m×n)
函数返回的值是"子串在主串中的位置"，即子串中第1个字符在主串字符序列中的"位置"，而非该字符在存储结构数组中的下标
对于一般文稿中串的匹配，算法4.6的时间复杂度可降为O(m+n)
4.2 KMP算法
核心思想是利用已经得到的部分匹配信息来进行后面的匹配过程。

## 树
1. 树的相关定义
&emsp;如果子树之间映射客观存在次序关系，则为“有序树”，否则为“无序树”。
&emsp;结点的度：其分支的个数定义为“结点的度”，如结点B的度为2，D的度为3。
&emsp;树的度：树中所有结点度的最大值定义为“树的度”。
&emsp;树的深度定义为树中叶子结点所在最大层次数。
2. 二叉树的一些规律
对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0＝n2＋1。
一棵深度为k且由2k-1个结点的二叉树称为满二叉树。满二叉树是完全二叉树的特例。
如果深度为k、由n个结点的二叉树中，当且仅当其每一个结点能够与深度为k的顺序编号的满二叉树从1到n标号的结点相对应，则称这样的二叉树为完全二叉树
具有n个结点的完全二叉树的深度为[log2n]＋1。
如果对一棵有n个结点的完全二叉树的结点按层序编号（从第1层到第[log2n]+1层，每层从左到右),则对任一结点i（1≤i≤n),有：
（1）如果i＝1，则结点i无双亲，是二叉树的根；如果i>1，则其双亲PARENT(i)是结点[i/2]。
（2）如果2i>n，则结点i为叶子结点，无左孩子；否则，其左孩子LCHILD(i)是结点2i。
（3）如果2i＋1>n，则结点i无右孩子；否则，其右孩子RCHILD(i)是结点2i＋1。
3. 二叉树的存储方法
二叉树的顺序存储:按编号
二叉链表法/三叉链表法
按原表达式建二叉链表算法
线索二叉树

4. 树的表示法
4.1 双亲表示法(连续空间存储)
以一组连续空间存储树的结点，同时在每个结点中附设一个指示器指示其双亲结点在链表中的位置
4.2 孩子表示法
节点可能有多个孩子,为了不浪费空间,构建孩子链表
4.3 孩子(兄弟)二叉链表法
树中每个结点都设有两个指针：
其一，firstchild指向该结点的“第一个”子树根结点；
其二，nextsibling指向它的“下一个”兄弟结点。

5. 森林和二叉树的转换
首先是树转二叉树,类似孩子二叉链表法.
森林转二叉树就是把所有的树根节点串起来.
所以反过来,二叉树一路向右走的节点是森林的各树的根节点.对应


6. 树的遍历
先根(次序)遍历树
后根(次序)遍历树

7. 森林的遍历
先序遍历森林
中序遍历森林
树的先根遍历，即森林的先序遍历可对应到二叉树的先序遍历；
树的后根遍历，即森林的中序遍历可对应到二叉树的中序遍历。
这里的二叉树的左子树代表节点的子树森林,右子树代表剩下的树.

## 数组
数组类型不作插入和删除的操作，因此只需要通过“顺序映象”得到它的存储结构，即借助数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。
通常有两种映象方法：即“以行(序)为主(序)”的映象方法和“以列(序)为主(序)”的映象方法。
数组中的任一元素可以在相同的时间内存取，即顺序存储的数组是一个随机存取结构。

## 矩阵
一、特殊矩阵的压缩存储方法
1. 对称矩阵
第i行恰有i+1个元素，元素总数为：n(n+1)/2
称sa[n(n+1)/2]为阶对称矩阵A的压缩存储
2. 三角矩阵
以主对角线划分，三角矩阵有上三角和下三角两种。
重复元素c可共享一个存储空间，其余的元素正好有n(n+1)/2个
因此，三角矩阵可压缩存储到向量sa[0..n(n+1)/2]中，其中c存放在向量的最后一个分量中。
3. 对角矩阵
除了主对角线和主对角线相邻两侧的若干条对角线上的元素之外，其余元素皆为零。

特点
一般都能找到矩阵中的元素与该向量的对应关系，通过这个关系，仍能对矩阵的元素进行随机存取。

二、稀疏矩阵的压缩存储方法 
1. 三元组顺序表
&emsp;三元组(i,j,aij)唯一确定了矩阵A中的一个非零值元,顺序存储结构作为三元组线性表的存储结构
三元组顺序表的转置
&emsp;对M中的每一列col(0≦col≦n-1)，通过从头至尾扫描三元表m.data，找出所有列号等于col的那些三元组，将它们的行号和列号互换后依次放入t.data中，即可得到T的按行优先的压缩存储表示。
O(nu\*tu)，即矩阵的列数和非零元的个数的乘积成正比。一般仅适用于tu<<mu\*nu的情况。
&emsp;快速转置
1.求M矩阵的每一列中非零元的个数；
2.确定T的每一行中第一个非零元在T.data中的序号；
3.将M.data中每个元素依次复制到T.data中相应位置。
O(M.nu+M.tu)。如果tu和mu×nu等数量级，则时间复杂度为O(mu×nu)
其中mu是行数,nu是列数,tu是非零元的个数
2. 行逻辑链接
在三元组顺序表的基础上加上指示每行开头的指针(由于使用的是顺序存储,加上的是指示下标的数组)
2.1 行两个矩阵相乘
![](https://img-blog.csdnimg.cn/2018112923484021.jpg)
先把M11和N的第一行相乘(结果分成三个),把M12和第二行相乘,把M13和第三行相乘,然后每三个结果累加得到第一行.主要因为行逻辑连接的一行元素放在一起,找起来比较方便

3. 十字链表
适合插入、删除之类的操作

## 广义表
可以嵌套的表,兼有线性结构和层次结构的特性
1.广义表的长度定义为最外层括弧中包含的数据元素个数；
2.广义表的深度定义为广义表书写形式中括弧的最大重数；
3.对于任意一个非空广义表LS=（a1,a2,a3,…,an)，它的第一个数据元素被定义为广义表的“表头”，Head(LS)=a1，而由其余数据元素构成的广义表被定义为广义表的“表尾”，Tail(LS)=(a2,a3,…,an)。

## 排序
1. 排序的分类
&emsp;稳定与不稳定
&emsp;(1)内部排序：指的是待排序记录存放在计算机随机存储器中进行的排序过程；
&emsp;(2)外部排序：指的是待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。
&emsp;移动位置的排序和(链)表排序和地址排序

2. 各种排序方式
2.1 插入排序
&emsp;一般情况下，直接插入排序的时间复杂度为O(n^2)。
&emsp;折半插入排序只能减少排序过程中关键字比较的时间，并不能减少记录移动的时间, 时间复杂度仍为O(n2)。
&emsp;2-路插入排序需要n个记录的辅助空间,减少了移动记录的次数,移动记录的次数约为(n^2)/8。
&emsp;具体做法是：另设一个和L.r同类型的数组d，首先将L.r[1]赋值给d[1]，并将d[1]看成是排好序的序列中处于中间位置的记录，然后从L.r中第2个记录起依次插入到d[1]之前或之后的有序序列中。先将待插记录的关键字和d[1]的关键字进行比较，若L.r[i].key<d[1].key，则将L.r[i]插入到d[1]之前的有序表中。反之，则将L.r[i]插入到d[1]之后的有序表中。
&emsp;表插入排序,在顺序表基础上附加了指针数组,先对这个链表使用插入排序,再最终重新排列整个表,也仅仅是减少了移动记录的时间，所以它的时间复杂度仍为O(n2)。
&emsp;重排过程需要修补链表的有序性,比如首先找到最小的数据,放在第一个,原来在1处的数据不可能放在空中,所以还是利用移出来的空间,也就是交换法,然而肯定后面有某个指针指向1,所以我们把1处的指针域指向另外那个地方,这样如果后面出现指向1的指针,只要看看1处数据的指针域就知道现在它放在哪里.
2.2 希尔排序
&emsp;又称“缩小增量排序”，它的基本思想是，先对待排序列进行“宏观调整”，待序列中的记录“基本有序”时再进行直接插入排序。
&emsp;例如一个含11个关键字的序列(16，25，12，30，47，11，23，36，9，18，31)，先对它进行“增量为5”的插入排序，即分别使(R1,R6,R11)、(R2,R7)、(R3,R8)、(R4,R9)和(R5,R10)为有序序列，然后将增量“缩小到3”，排序结果使(R1,R4,R7,R10)、(R2,R5,R8,R11)和(R3,R6,R9)分别成为有序序列，此时序列中在关键字18，23，25，31和47之前的关键字均比它们小，即在进行最后一趟排序时这几个关键字都不需要“往前进行”插入，之后经过最后一趟插入排序即得到有序序列。
应使增量序列中的值没有除1之外的公因子，并且最后一个增量值必须等于1。
当增量序列为dlta[k]=2t-k-1-1(1≤k≤t≤)时，希尔排序的时间复杂度为O(n3/2)。
2.3 快速排序
&emsp;快速排序是起泡排序的一种改进，其基本思想：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。是一种不稳定的排序算法
&emsp;通常进行的快速排序采用“三者取中”的改进方案，即以L.r[low]、L.r[high]和L.r[(low+high)/2]三者中关键字介于中值者为枢轴。
&emsp;快速排序和归并排序在n值较小时的性能不及直接插入排序
2.4 选择排序
2.4.1 简单选择排序
时间复杂度为：O(n2)
2.4.2 树形选择排序
树形选择排序（Tree Selection Sort），又称锦标赛排序（Tournament Sort），是一种按照锦标赛思想进行选择排序的方法。
先第一次打锦标赛, 建立二叉树,得到最小值, 然后把叶子节点的最小值改成最大值, 再不停对上升路径打锦标赛, 得到次小值.
在树形选择排序中，除了最小关键字以外，每选择一个次小关键字仅需进行[log2n]次比较，因此，它的时间复杂度为O(nlogn)。
2.4.3 堆排序
在第一趟选最大或最小关键字记录时先“建堆”
建立堆时, 先建立完全二叉树, 先把叶子节点看作很多个堆, 从最后一个非叶子节点(第n/2个节点)向前开始筛选合并堆.
可以证明，堆排序的时间复杂度为O(nlogn)。和选择排序相同，无论待排序列中的记录是正序还是逆序排列，都不会使堆排序处于“最好”或“最坏”的状态。
2.5 归并排序
对一个长度为n 的记录序列需进行趟的归并，而每一趟需进行关键字比较和记录移动的时间和n 成正比。
因此，2-路归并排序的时间复杂度为O (nlogn)。
2.6 基数排序
借助“多关键字排序”的思想，实现“单关键字排序”的算法。借助“分配”和“收集”两种操作对单逻辑关键字进行排序.
一是最高位优先(MSD法)，另一是最低位优先(LSD法)。
最低位优先的做法是，在继续对“前一位”排序时不需要将当前所得对其后一位有序的序列分割成若干子序列进行，而是整个序列依次对Kd-1、对Kd-2直至对K0进行排序即可。
假如多关键字的记录序列中，每个关键字的取值范围相同，则按LSD法进行排序时，可以采用“分配-收集”的方法，其好处是不需要进行关键字之间的比较。
分配时，按当前“关键字位”取值，将记录分配到不同的链队列中，每个队列中记录的“关键字位”相同；
收集时，按当前关键字位取值从小到大将各队列首尾相链成一个链表；
链式基数排序的时间复杂度：假设n为记录个数，rd为基数值，d为构成逻辑关键字的关键字位数。一趟“分配”的时间复杂度是O(n)一趟的收集”复杂度是O(rd)总的时间复杂度为O(d(n+rd))一般情况下，相比n而言，rd要小得多，因此可简写为O(dn)。
3. 比较
简单选择排序、堆排序和归并排序的时间性能不随记录序列中关键字的分布而改变。
当待排记录序列按关键字顺序有序时，直接插入排序和起泡排序能达到O(n)的时间复杂度；而对于快速排序而言，这是最不好的情况，此时的时间性能蜕化为O (n2)，因此应尽量避免。宁可选用堆排序或归并排序，而后两者的最大差别是所需辅助空间不等。
时间复杂度的讨论主要考虑排序过程中所需进行的关键字间的比较次数. 当待排序记录中其它各数据项比关键字占有更大的数据量时，还应考虑到排序过程中移动记录的操作时间. 从这个观点考虑，简单排序的三种排序方法中起泡排序效率最低。
空间复杂度
1.所有的简单排序方法（包括：直接插入、起泡和简单选择排序）和堆排序的空间复杂度均为O(1)。
2.快速排序为O(logn)，为递归程序执行过程中栈所需的辅助空间。
3.归并排序和基数排序所需辅助空间最多，其空间复杂度为O(n)。
4.链式基数排序需附设队列首尾指针，空间复杂度O(rd+n)
希尔排序、快速排序和堆排序是不稳定的排序方法
快速排序和归并排序在n值较小时的性能不及直接插入排序, 可和插入排序“混合”使用。

## 图
1. 相关概念
&emsp;完全图：有n(n-1)/2条边的无向图。其中n是结点个数。
&emsp;有向完全图：有n(n-1)条边的有向图。其中n是结点个数。
&emsp;有很少的边或弧（e<nlogn）的图称为稀疏图，反之成为稠密图。
&emsp;边和弧相关的数叫做边的权值，边有权的图称之为网。
&emsp;邻接点：无向图G=(V,{E})，如果边(V,V’)∈E，则称V和V’互为邻接点。边(V,V’)和顶点V，V’相关联。
&emsp;顶点的度:对无向图而言，邻接点的个数定义为顶点的度（TD）。对有向图而言，顶点的度为其出度和入度之和
&emsp;子图: 假设有两个图G=(V,{E})和G’=(V’,{E’})，如果V’⊆V且E’⊆E，则称G’为G的子图(subgraph)。
&emsp;强连通图: 有向图中任意两个顶点之间都存在一条有向路径。
&emsp;强连通分量: 把有向图拆开成极大的强连通子图
2. 存储结构
2.1 邻接矩阵
&emsp;网的邻接矩阵的定义为，当vi到vj有弧相邻接时，ai,j的值应为该弧上的权值，否则为∞。有向图的邻接矩阵不一定对称。
&emsp;构造一个具有n个顶点和e条边的无向网G的时间复杂度是O(n^2+e×n)，其中对邻接矩阵G.arcs的初始化耗费了O(n2)的时间。
2.2 邻接表
&emsp;类似于树的孩子链表，将和同一顶点“相邻接”的所有邻接点链接在一个单链表中
&emsp;而有向图的邻接表的单链表保存的只是该节点发出指向的元素. 虽然在邻接表中也能找到所有以某个顶点为弧头的弧，但必须查询整个邻接表。
&emsp;若在应用问题中主要是对以某个顶点为弧头的弧进行操作，则可以为该有向图建立一个“逆邻接表”
3. 图的遍历
&emsp;图的“遍历”是对图中的每个顶点都进行一次访问且仅进行一次访问。给每个顶点设置一个访问标志.
&emsp;对于非连通图, 只能对图中所有顶点巡查一遍“挨个检查”，即从第一个顶点起，如果该顶点未被访问，则从该顶点出发进行深度优先遍历，否则接着检查下一顶点，直至所有顶点都被访问到为止。
3.1 深度优先搜索
&emsp;而当以邻接表作图的存储结构时，找邻接点所需时间为O(e)，其中e为无向图中边的数或有向图中弧的数。由此，当以邻接表作存储结构时，深度优先搜索遍历图的时间复杂度为O(n+e)。
3.2 广度优先搜索
&emsp;需要一个队列保存被访问顶点的次序访问后就把相邻的节点进队列. 所以上一轮先访问的节点的相邻节点在下一轮先访问
若采用同样的存储结构，广度优先遍历的时间复杂度和深度优先遍历相同
4. 无向图的连通分量和生成树
生成树：极小连通子图.
在生成树中添加一条边之后，必定会形成回路或环。
&emsp;进行深度为主的遍历或广度为主的遍历，得到深度优先生成树或广度优先生成树。对于非连通图，将得到多棵深度优先生成树或广度优先生成树。称之为生成森林。
5. 最小生成树
&emsp;最小生成树(Minimum Cost Spanning Tree)：生成树中边的权值（代价）之和最小的树。
&emsp;性质：假设G = {V, { E } } 是一个连通图，U 是结点集合V 的一个非空子集。若( u, v ) 是一条代价最小的边，且u 属于U, v 属于V-U，则必存在一棵包括边( u, v ) 在内的最小代价生成树。(反证法证明)
5.1 普里姆算法
首先选取图中任意一个顶点v作为生成树的根
往生成树中添加顶点w。w和v之间必须有边，且权值在和v相邻接的边中最小。这个最小是在已经生成一半的树节点和剩下节点的所有边中最小的.
&emsp;需要附设一个辅助数组closedge，以记录从集合U到集合V-U中每个顶点当前的权值最小边。
&emsp;每个顶点都是通过“一条边”加入到生成树上的.
&emsp;普里姆算法的时间复杂度为O(n2)，与网中的边数无关，因此适用于求边稠密的网的最小生成树。
5.2 克鲁斯卡尔算法
应从权值最小的边选起，直至选出n-1条互不构成回路的权值最小边为止。
首先构造一个只含n个顶点的森林
然后依权值从小到大从连通网中选择不使森林中产生回路的边加入到森林中去
直至该森林变成一棵树为止，这棵树便是连通网的最小生成树。
判别当前权值最小边是否可取只要判别它的两个顶点是否在同一棵树上即可。
不考虑建立图的存储结构的时间，则时间复杂度为O(eloge)(e为网中边的数目)，适合于求边稀疏的网的最小生成树。
6. 最短路径
讨论带权有向图(有向网)，并称路径中的第一个顶点为“源点”，路径中的最后一个顶点为“终点”。
6.1 迪杰斯特拉算法
(边的权值不可以为负值)
类似于普里姆算法，在算法中应保存当前已得到的从源点到每个终点的最短路径
初值为：如果从源点到该点有弧，则存在一条路径，其路径长度即为该弧上的权值
之后每求得一条到达某个终点w的“最短路径”之后，就需要检查一下，是否存在经过这个顶点w的其它路径(即是否存在从顶点w出发到尚未求得最短路径顶点的弧)，如果存在，其长度是否比当前求得的路径长度短，如果是，则应修改当前路径。
迪杰斯特拉算法的时间复杂度和普里姆算法相同，也是O(n2)
拓扑排序、关键路径










































